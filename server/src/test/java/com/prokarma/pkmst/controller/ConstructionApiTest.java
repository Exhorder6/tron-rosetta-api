/*
 * Rosetta
 * Build Once. Integrate Your Blockchain Everywhere.
 *
 * The version of the OpenAPI document: 1.4.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.prokarma.pkmst.controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.prokarma.pkmst.model.ConstructionCombineRequest;
import com.prokarma.pkmst.model.ConstructionCombineResponse;
import com.prokarma.pkmst.model.ConstructionDeriveRequest;
import com.prokarma.pkmst.model.ConstructionDeriveResponse;
import com.prokarma.pkmst.model.ConstructionHashRequest;
import com.prokarma.pkmst.model.ConstructionHashResponse;
import com.prokarma.pkmst.model.ConstructionMetadataRequest;
import com.prokarma.pkmst.model.ConstructionMetadataResponse;
import com.prokarma.pkmst.model.ConstructionParseRequest;
import com.prokarma.pkmst.model.ConstructionParseResponse;
import com.prokarma.pkmst.model.ConstructionPayloadsRequest;
import com.prokarma.pkmst.model.ConstructionPayloadsResponse;
import com.prokarma.pkmst.model.ConstructionPreprocessRequest;
import com.prokarma.pkmst.model.ConstructionPreprocessResponse;
import com.prokarma.pkmst.model.ConstructionSubmitRequest;
import com.prokarma.pkmst.model.ConstructionSubmitResponse;
import com.prokarma.pkmst.model.Error;
import org.junit.Test;
import org.junit.Ignore;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.http.ResponseEntity;
import org.springframework.web.multipart.MultipartFile;

/**
 * API tests for ConstructionApi
 */
@Ignore
public class ConstructionApiTest {

    private final ObjectMapper objectMapper = new ObjectMapper();

    private final ConstructionApi api = new ConstructionApiController(objectMapper);

    private final String accept = "application/json";

    
    /**
     * Create Network Transaction from Signatures
     *
     * Combine creates a network-specific transaction from an unsigned transaction and an array of provided signatures. The signed transaction returned from this method will be sent to the &#x60;/construction/submit&#x60; endpoint by the caller.
     *
     * @throws Exception
     *          if the Api call fails
     */
    @Test
    public void constructionCombineTest() throws Exception {
        ConstructionCombineRequest constructionCombineRequest = null;
    ResponseEntity<ConstructionCombineResponse> response = api.constructionCombine(constructionCombineRequest , accept);

        // TODO: test validations
    }
    
    /**
     * Derive an Address from a PublicKey
     *
     * Derive returns the network-specific address associated with a public key. Blockchains that require an on-chain action to create an account should not implement this method.
     *
     * @throws Exception
     *          if the Api call fails
     */
    @Test
    public void constructionDeriveTest() throws Exception {
        ConstructionDeriveRequest constructionDeriveRequest = null;
    ResponseEntity<ConstructionDeriveResponse> response = api.constructionDerive(constructionDeriveRequest , accept);

        // TODO: test validations
    }
    
    /**
     * Get the Hash of a Signed Transaction
     *
     * TransactionHash returns the network-specific transaction hash for a signed transaction.
     *
     * @throws Exception
     *          if the Api call fails
     */
    @Test
    public void constructionHashTest() throws Exception {
        ConstructionHashRequest constructionHashRequest = null;
    ResponseEntity<ConstructionHashResponse> response = api.constructionHash(constructionHashRequest , accept);

        // TODO: test validations
    }
    
    /**
     * Get Metadata for Transaction Construction
     *
     * Get any information required to construct a transaction for a specific network. Metadata returned here could be a recent hash to use, an account sequence number, or even arbitrary chain state. The request used when calling this endpoint is often created by calling &#x60;/construction/preprocess&#x60; in an offline environment. It is important to clarify that this endpoint should not pre-construct any transactions for the client (this should happen in &#x60;/construction/payloads&#x60;). This endpoint is left purposely unstructured because of the wide scope of metadata that could be required.
     *
     * @throws Exception
     *          if the Api call fails
     */
    @Test
    public void constructionMetadataTest() throws Exception {
        ConstructionMetadataRequest constructionMetadataRequest = null;
    ResponseEntity<ConstructionMetadataResponse> response = api.constructionMetadata(constructionMetadataRequest , accept);

        // TODO: test validations
    }
    
    /**
     * Parse a Transaction
     *
     * Parse is called on both unsigned and signed transactions to understand the intent of the formulated transaction. This is run as a sanity check before signing (after &#x60;/construction/payloads&#x60;) and before broadcast (after &#x60;/construction/combine&#x60;). 
     *
     * @throws Exception
     *          if the Api call fails
     */
    @Test
    public void constructionParseTest() throws Exception {
        ConstructionParseRequest constructionParseRequest = null;
    ResponseEntity<ConstructionParseResponse> response = api.constructionParse(constructionParseRequest , accept);

        // TODO: test validations
    }
    
    /**
     * Generate an Unsigned Transaction and Signing Payloads
     *
     * Payloads is called with an array of operations and the response from &#x60;/construction/metadata&#x60;. It returns an unsigned transaction blob and a collection of payloads that must be signed by particular addresses using a certain SignatureType. The array of operations provided in transaction construction often times can not specify all \&quot;effects\&quot; of a transaction (consider invoked transactions in Ethereum). However, they can deterministically specify the \&quot;intent\&quot; of the transaction, which is sufficient for construction. For this reason, parsing the corresponding transaction in the Data API (when it lands on chain) will contain a superset of whatever operations were provided during construction.
     *
     * @throws Exception
     *          if the Api call fails
     */
    @Test
    public void constructionPayloadsTest() throws Exception {
        ConstructionPayloadsRequest constructionPayloadsRequest = null;
    ResponseEntity<ConstructionPayloadsResponse> response = api.constructionPayloads(constructionPayloadsRequest , accept);

        // TODO: test validations
    }
    
    /**
     * Create a Request to Fetch Metadata
     *
     * Preprocess is called prior to &#x60;/construction/payloads&#x60; to construct a request for any metadata that is needed for transaction construction given (i.e. account nonce). The request returned from this method will be used by the caller (in a different execution environment) to call the &#x60;/construction/metadata&#x60; endpoint.
     *
     * @throws Exception
     *          if the Api call fails
     */
    @Test
    public void constructionPreprocessTest() throws Exception {
        ConstructionPreprocessRequest constructionPreprocessRequest = null;
    ResponseEntity<ConstructionPreprocessResponse> response = api.constructionPreprocess(constructionPreprocessRequest , accept);

        // TODO: test validations
    }
    
    /**
     * Submit a Signed Transaction
     *
     * Submit a pre-signed transaction to the node. This call should not block on the transaction being included in a block. Rather, it should return immediately with an indication of whether or not the transaction was included in the mempool. The transaction submission response should only return a 200 status if the submitted transaction could be included in the mempool. Otherwise, it should return an error.
     *
     * @throws Exception
     *          if the Api call fails
     */
    @Test
    public void constructionSubmitTest() throws Exception {
        ConstructionSubmitRequest constructionSubmitRequest = null;
    ResponseEntity<ConstructionSubmitResponse> response = api.constructionSubmit(constructionSubmitRequest , accept);

        // TODO: test validations
    }
    
}
